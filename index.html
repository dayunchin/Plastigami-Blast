<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plastigami Blast Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bangers&family=Fredoka+One&family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --board-size: 8;
            --tile-size: min(10vw, 55px);
            --board-bg: #f0f8ff;
            --score-bg: #fff;
            --text-dark: #333;
            --accent-color: #4A90E2; 
        }

        body {
            font-family: 'Roboto', sans-serif;
            margin: 0;
            user-select: none;
            overflow: hidden;
        }

        #intro-page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/Plastigami%20Blast%20bg.jpg');
            background-size: cover;
            background-position: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 200;
            transition: opacity 0.5s ease-out;
            color: white;
            padding: 20px;
            box-sizing: border-box;
        }

        #intro-title {
            font-family: 'Bangers', cursive;
            font-size: clamp(3rem, 12vw, 7rem);
            text-shadow: 5px 5px 0px #000, -2px -2px 0px #000, 2px -2px 0px #000, -2px 2px 0px #000, 2px 2px 0px #000;
            letter-spacing: 5px;
            margin-bottom: 40px;
        }
        
        #start-game-button {
            font-family: 'Fredoka One', cursive;
            font-size: 1.5rem;
            padding: 15px 30px;
            border-radius: 15px;
            border: 3px solid white;
            background-color: var(--accent-color);
            color: white;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: transform 0.2s, background-color 0.2s;
        }
        #start-game-button:hover {
            transform: scale(1.05);
            background-color: #3a7bc8;
        }

        .game-wrapper {
            display: none;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            gap: 20px;
            flex-wrap: wrap;
            background: linear-gradient(135deg, #e0eafc 0%, #cfdef3 100%);
        }

        .main-content { display: flex; flex-direction: column; align-items: center; }
        .game-container {
            position: relative; display: flex; flex-direction: column;
            align-items: center; gap: 15px; padding: 20px;
            background-color: rgba(255, 255, 255, 0.7); border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1); backdrop-filter: blur(10px);
            width: fit-content;
        }
        h1 {
           font-family: 'Bangers', cursive;
            font-size: clamp(3rem, 12vw, 7rem);
            text-shadow: 5px 5px 0px #000, -2px -2px 0px #000, 2px -2px 0px #000, -2px 2px 0px #000, 2px 2px 0px #000;
            letter-spacing: 5px;
            margin-bottom: 40px;
           // font-family: 'Fredoka One', cursive; color: var(--accent-color);
            //text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
 font-size: 2.2rem; margin: 0;
        }
        .stats-container {
            display: flex; justify-content: space-around; width: 100%;
            padding: 10px 0; background: var(--score-bg); border-radius: 15px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.05);
        }
        .stat { text-align: center; padding: 0 15px; color: var(--text-dark); }
        .stat-label { font-size: 0.8rem; color: #666; }
        .stat-value { font-size: 1.4rem; font-weight: 700; color: var(--accent-color); }
        #game-board {
            display: grid;
            grid-template-columns: repeat(var(--board-size), var(--tile-size));
            grid-template-rows: repeat(var(--board-size), var(--tile-size));
            gap: 4px; background-color: var(--board-bg); padding: 8px;
            border-radius: 15px; border: 5px solid #fff;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .tile {
            width: var(--tile-size); height: var(--tile-size); display: flex;
            justify-content: center; align-items: center;
            font-size: calc(var(--tile-size) * 0.7); cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            border-radius: 10px; background: rgba(255,255,255,0.5);
        }
        .tile img {
            width: 90%;
            height: 90%;
            object-fit: contain;
            pointer-events: none; /* Make sure clicks go to the tile div */
        }
        .tile.selected { transform: scale(1.1); box-shadow: 0 0 15px var(--accent-color); background-color: #fff; }
        .tile.match { animation: blast 0.5s ease-out forwards; }
        @keyframes blast {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.5; }
            100% { transform: scale(0); opacity: 0; }
        }
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.6); display: flex;
            justify-content: center; align-items: center; z-index: 100;
            opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
        }
        .modal.visible { opacity: 1; pointer-events: auto; }
        .modal-content {
            background: white; padding: 30px 40px; border-radius: 20px;
            text-align: center; box-shadow: 0 10px 25px rgba(0,0,0,0.2);
            transform: scale(0.7); transition: transform 0.3s ease;
        }
        .modal.visible .modal-content { transform: scale(1); }
        .modal-content h2 {
            font-family: 'Fredoka One', cursive; font-size: 2rem;
            color: var(--accent-color); margin-bottom: 15px;
        }
        .modal-content p { margin-bottom: 25px; font-size: 1.1rem; color: #555; }
        .modal-button {
            background-color: var(--accent-color); color: white; border: none;
            padding: 12px 25px; border-radius: 10px; font-size: 1rem;
            font-weight: bold; cursor: pointer; transition: background-color 0.2s, transform 0.2s;
        }
        .modal-button:hover { background-color: #3a7bc8; transform: translateY(-2px); }
        #mute-button {
            position: absolute; top: 15px; right: 15px; background: #fff;
            border: 2px solid var(--accent-color); border-radius: 50%;
            width: 35px; height: 35px; font-size: 18px; cursor: pointer;
            display: flex; align-items: center; justify-content: center; color: var(--accent-color);
        }
    </style>
</head>
<body>

    <div id="intro-page">
        <h1 id="intro-title">Plastigami Blast</h1>
        <button id="start-game-button">Start Game</button>
    </div>

    <div class="game-wrapper">
        <div class="main-content">
            <div class="game-container">
                <button id="mute-button">ðŸ”Š</button>
                <h1>Plastigami Blast</h1>
                <div class="stats-container">
                    <div class="stat">
                        <div class="stat-label">LEVEL</div>
                        <div id="level" class="stat-value">1</div>
                    </div>
                    <div class="stat">
                        <div class="stat-label">SCORE</div>
                        <div id="score" class="stat-value">0</div>
                    </div>
                    <div class="stat">
                        <div class="stat-label">MOVES</div>
                        <div id="moves" class="stat-value">30</div>
                    </div>
                </div>
                <div id="game-board"></div>
            </div>
        </div>
    </div>
    
    <div id="game-over-modal" class="modal">
        <div class="modal-content">
            <h2 id="modal-title">Game Over!</h2>
            <p id="modal-text">You've run out of moves!</p>
            <button id="restart-button" class="modal-button" style="margin-top: 10px;">Play Again</button>
        </div>
    </div>
    
    <script type="module">
        const BOARD_SIZE = 8;
        const LEVEL_ORIGAMI = [
  ['https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0101.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0102.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0103.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0104.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0105.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0106.png'],
            // Level 2
            ['https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0201.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0202.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0203.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0204.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0205.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0206.png'],
            // Level 3
          ['https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0301.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0302.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0303.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0304.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0305.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0306.png'],
            // Level 4
            ['https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0401.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0402.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0403.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0404.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0405.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0406.png'],
            // Level 5
         ['https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0501.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0502.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0503.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0504.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0505.png', 
	'https://raw.githubusercontent.com/dayunchin/Plastigami-Blast/main/b0506.png']
        ];
        const POINTS_PER_ORIGAMI = 10;
        const LEVEL_GOALS = [1000, 2000, 3500, 5000, 7000];
        const MOVES_PER_LEVEL = [30, 40, 50, 55, 60];

        const introPage = document.getElementById('intro-page');
        const startGameButton = document.getElementById('start-game-button');
        const gameWrapper = document.querySelector('.game-wrapper');
        const boardElement = document.getElementById('game-board');
        const scoreElement = document.getElementById('score');
        const movesElement = document.getElementById('moves');
        const levelElement = document.getElementById('level');
        const modalElement = document.getElementById('game-over-modal');
        const modalTitleElement = document.getElementById('modal-title');
        const modalTextElement = document.getElementById('modal-text');
        const restartButton = document.getElementById('restart-button');
        const muteButton = document.getElementById('mute-button');

        let board = [], score = 0, moves = 0, currentLevel = 1;
        let selectedTile = null, isProcessing = false, isMuted = false;
        let origami = LEVEL_ORIGAMI[0];

        // --- New MP3 Sound Palette ---
        const soundPlayers = new Tone.Players({
            urls: {
                    urls: {
                intro: "sounds/intro.mp3",
                match3: "sounds/explosion01.mp3",
                match4: "sounds/explosion02.mp3",
                match5: "sounds/explosion03.mp3",
                swap: "sounds/swap.mp3",
                levelWin: "sounds/win.mp3",
                gameOver: "sounds/fail.mp3"
            },
            onload: () => console.log("All sounds loaded."),
            onerror: (error) => console.error("Error loading sounds:", error),
        }).toDestination();
	    soundPlayers.autostart = true;
        soundPlayers.player("intro").loop = true;

        function playSound(type, volume = 0) {
            if (isMuted || !soundPlayers.loaded) return;
            try {
                const player = soundPlayers.player(type);
                player.volume.value = volume;
                player.start();
            } catch (e) { console.error(`Audio playback error for type "${type}":`, e); }
        }

        function createOrigami() { return origami[Math.floor(Math.random() * origami.length)]; }

        function initializeBoard() {
            board = Array.from({ length: BOARD_SIZE }, () => Array.from({ length: BOARD_SIZE }, createOrigami));
            while (!hasPossibleMoves(board) || checkForMatches(board).length > 0) {
                 for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        if (checkForMatches(board).some(group => group.some(tile => tile.row === r && tile.col === c))) {
                            board[r][c] = createOrigami();
                        }
                    }
                }
            }
        }

        function renderBoard() {
            boardElement.innerHTML = '';
            board.forEach((row, r) => {
                row.forEach((item, c) => {
                    const tile = document.createElement('div');
                    tile.classList.add('tile');
                    tile.dataset.row = r; tile.dataset.col = c;
                    
                    const img = document.createElement('img');
                    img.src = item;
                    tile.appendChild(img);
                    
                    tile.addEventListener('click', handleTileClick);
                    boardElement.appendChild(tile);
                });
            });
        }
        
        function beginGame(level) {
            currentLevel = level;
            origami = LEVEL_ORIGAMI[currentLevel - 1] || LEVEL_ORIGAMI[0];
            score = 0; moves = MOVES_PER_LEVEL[currentLevel - 1] || MOVES_PER_LEVEL[0];
            isProcessing = false; selectedTile = null;
            updateStats(); initializeBoard(); renderBoard();
            modalElement.classList.remove('visible');
        }

        function updateStats() { scoreElement.textContent = score; movesElement.textContent = moves; levelElement.textContent = currentLevel; }

        function handleTileClick(event) {
            if (isProcessing) return;
            const clickedTileElement = event.target;
            const row = parseInt(clickedTileElement.dataset.row);
            const col = parseInt(clickedTileElement.dataset.col);
            if (!selectedTile) {
                selectedTile = { row, col, element: clickedTileElement };
                clickedTileElement.classList.add('selected');
            } else {
                const first = selectedTile;
                const second = { row, col, element: clickedTileElement };
                first.element.classList.remove('selected');
                if (Math.abs(first.row - second.row) + Math.abs(first.col - second.col) === 1) {
                    swapAndProcess(first, second);
                }
                selectedTile = null;
            }
        }

        async function swapAndProcess(tile1, tile2) {
            isProcessing = true; playSound('swap', -8); moves--; updateStats();
            let tempBoard = board.map(r => [...r]);
            const temp = tempBoard[tile1.row][tile1.col];
            tempBoard[tile1.row][tile1.col] = tempBoard[tile2.row][tile2.col];
            tempBoard[tile2.row][tile2.col] = temp;
            const matchGroups = checkForMatches(tempBoard);
            if (matchGroups.length > 0) {
                board = tempBoard; renderBoard(); await processMatches(matchGroups);
            } else { moves++; updateStats(); }
            isProcessing = false; checkGameState();
        }
        
        async function processMatches(initialMatchGroups) {
             let matchGroups = initialMatchGroups;
             while(matchGroups.length > 0) {
                const flatMatches = [...new Set(matchGroups.flat().map(t => `${t.row}-${t.col}`))];
                if (flatMatches.length >= 5) playSound('match5', 0);
                else if (flatMatches.length === 4) playSound('match4', -3);
                else playSound('match3', -6);
                score += flatMatches.length * POINTS_PER_ORIGAMI; updateStats();
                await removeMatches(flatMatches.map(id => { const [row, col] = id.split('-').map(Number); return {row, col}; }));
                await refillBoard();
                matchGroups = checkForMatches(board);
             }
        }

        function checkForMatches(currentBoard) {
            const allMatchGroups = []; const visited = new Set();
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const key = `${r}-${c}`; if (visited.has(key)) continue;
                    const item = currentBoard[r][c]; if (!item) continue;
                    const horizontalMatch = [{ row: r, col: c }];
                    for (let i = c + 1; i < BOARD_SIZE; i++) { if (currentBoard[r][i] === item) { horizontalMatch.push({ row: r, col: i }); } else { break; } }
                    if (horizontalMatch.length >= 3) { allMatchGroups.push(horizontalMatch); horizontalMatch.forEach(tile => visited.add(`${tile.row}-${tile.col}`)); }
                    const verticalMatch = [{ row: r, col: c }];
                    for (let i = r + 1; i < BOARD_SIZE; i++) { if (currentBoard[i][c] === item) { verticalMatch.push({ row: i, col: c }); } else { break; } }
                    if (verticalMatch.length >= 3) { allMatchGroups.push(verticalMatch); verticalMatch.forEach(tile => visited.add(`${tile.row}-${tile.col}`)); }
                }
            }
            return allMatchGroups;
        }
        
        function hasPossibleMoves(currentBoard) {
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const temp = currentBoard[r][c];
                    if (c < BOARD_SIZE - 1) {
                        currentBoard[r][c] = currentBoard[r][c + 1]; currentBoard[r][c + 1] = temp;
                        if (checkForMatches(currentBoard).length > 0) { currentBoard[r][c + 1] = currentBoard[r][c]; currentBoard[r][c] = temp; return true; }
                        currentBoard[r][c + 1] = currentBoard[r][c]; currentBoard[r][c] = temp;
                    }
                    if (r < BOARD_SIZE - 1) {
                        currentBoard[r][c] = currentBoard[r + 1][c]; currentBoard[r + 1][c] = temp;
                        if (checkForMatches(currentBoard).length > 0) { currentBoard[r + 1][c] = currentBoard[r][c]; currentBoard[r][c] = temp; return true; }
                        currentBoard[r + 1][c] = currentBoard[r][c]; currentBoard[r][c] = temp;
                    }
                }
            }
            return false;
        }

        function removeMatches(matches) {
            return new Promise(resolve => {
                matches.forEach(({ row, col }) => {
                    const tileElement = document.querySelector(`.tile[data-row='${row}'][data-col='${col}']`);
                    if(tileElement) tileElement.classList.add('match');
                    board[row][col] = null;
                });
                setTimeout(() => resolve(), 500);
            });
        }

        async function refillBoard() {
            return new Promise(async resolve => {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    let emptyRow = BOARD_SIZE - 1;
                    for (let r = BOARD_SIZE - 1; r >= 0; r--) {
                        if (board[r][c] !== null) {
                            if (r !== emptyRow) { board[emptyRow][c] = board[r][c]; board[r][c] = null; }
                            emptyRow--;
                        }
                    }
                }
                for (let r = 0; r < BOARD_SIZE; r++) { for (let c = 0; c < BOARD_SIZE; c++) { if (board[r][c] === null) { board[r][c] = createOrigami(); } } }
                while (!hasPossibleMoves(board)) { for(let r=0; r < BOARD_SIZE; r++) { for(let c=0; c < BOARD_SIZE; c++) { board[r][c] = createOrigami(); } } }
                renderBoard(); await new Promise(r => setTimeout(r, 100));
                resolve();
            });
        }

        function checkGameState() {
            const goal = LEVEL_GOALS[currentLevel - 1];
            if (score >= goal) {
                playSound('levelWin', 0);
                modalTitleElement.textContent = `Level ${currentLevel} Complete!`;
                modalTextElement.textContent = `You scored ${score} points!`;
                if(currentLevel < LEVEL_GOALS.length) {
                    restartButton.textContent = `Start Level ${currentLevel + 1}`;
                    restartButton.onclick = () => beginGame(currentLevel + 1);
                } else {
                    modalTitleElement.textContent = `Congratulations! You Won!`;
                    modalTextElement.textContent = `You've completed all levels! Final Score: ${score}`;
                    restartButton.textContent = 'Play Again From Start';
                    restartButton.onclick = () => beginGame(1);
                }
                modalElement.classList.add('visible');
            } else if (moves <= 0) {
                playSound('gameOver', 0);
                modalTitleElement.textContent = 'Game Over!';
                modalTextElement.textContent = `You ran out of moves. Final Score: ${score}`;
                restartButton.textContent = 'Restart Level';
                restartButton.onclick = () => beginGame(currentLevel);
                modalElement.classList.add('visible');
            }
        }
        
        // --- Event Listeners ---
        async function startAudio() {
            await Tone.start();
            console.log("Audio context started");
            if (soundPlayers.loaded && !isMuted) {
                soundPlayers.player("intro").start();
            }
        }

        startGameButton.addEventListener('click', () => {
            if (Tone.context.state !== 'running') {
                startAudio();
            }
            
            if (soundPlayers.player("intro").state === 'started') {
                soundPlayers.player("intro").stop(Tone.now() + 0.5);
            }
            
            introPage.style.opacity = '0';
            setTimeout(() => {
                introPage.style.display = 'none';
                gameWrapper.style.display = 'flex';
                document.body.style.overflow = 'auto';
            }, 500);
            beginGame(1);
        });

        muteButton.addEventListener('click', () => {
            if (Tone.context.state !== 'running') { startAudio(); }
            isMuted = !isMuted;
            muteButton.textContent = isMuted ? 'ðŸ”‡' : 'ðŸ”Š';
            if (soundPlayers.player("intro").state === 'started' && isMuted) {
                soundPlayers.player("intro").stop();
            } else if (soundPlayers.loaded && soundPlayers.player("intro").state !== 'started' && !isMuted && introPage.style.opacity !== '0') {
                soundPlayers.player("intro").start();
            }
        });

        muteButton.textContent = isMuted ? 'ðŸ”‡' : 'ðŸ”Š';
    </script>
</body>
</html>





